import "dotenv/config";
import {
  Client,
  GatewayIntentBits,
  Partials,
  Events,
  EmbedBuilder,
} from "discord.js";
import fs from "fs";

const client = new Client({
  intents: [
    GatewayIntentBits.Guilds,
    GatewayIntentBits.GuildMembers,
    GatewayIntentBits.GuildMessages,
    GatewayIntentBits.GuildMessageReactions,
    GatewayIntentBits.MessageContent, // Necesario para leer el contenido de los mensajes
  ],
  partials: [Partials.Message, Partials.Channel, Partials.Reaction],
});

const CHANNEL_ID_BIENVENIDA = process.env.CHANNEL_ID_BIENVENIDA;
const CHANNEL_ID_REGLAS = process.env.CHANNEL_ID_REGLAS;
const CHANNEL_ID_PRESENTACION = process.env.CHANNEL_ID_PRESENTACION;
const CHANNEL_ID_ROLES = process.env.CHANNEL_ID_ROLES;
const UNVERIFIED_ROLE_ID = process.env.ROLE_ID_UNVERIFIED;
const VERIFICATION_EMOJI = "‚úÖ";

let MESSAGE_ID_ROLES = process.env.MESSAGE_ID_ROLES;
let MESSAGE_ID_REGLAS = process.env.MESSAGE_ID_REGLAS;

const SPAM_WEBHOOK_URL = process.env.SPAM_WEBHOOK_URL; // Webhook para notificaciones de spam
const SPAM_THRESHOLD = 5; // Cantidad de mensajes id√©nticos para considerar spam
const SPAM_TIME_WINDOW = 30000; // Ventana de tiempo en milisegundos para detectar spam (30 segundos)
const SPAM_KEYWORDS = [
  "nitro",
  "gratis",
  "free",
  "regalo",
  "sorteo",
  "invita",
  "link",
  "discord.gg",
  "phishing",
]; // Palabras clave comunes en mensajes de spam

const recentMessages = new Map(); // Almacena los mensajes recientes para la detecci√≥n de spam

const ROLES = {
  "üíõ": process.env.ROLE_ID_ESTUDIANTE,
  "üíú": process.env.ROLE_ID_PROFE,
  "‚ù§Ô∏è": process.env.ROLE_ID_VOLUNTARIE,
  "üß°": process.env.ROLE_ID_COMUNIDAD,
};

// helper para guardar el ID de un mensaje en .env
function saveIdToEnv(key, id) {
  const envPath = ".env";
  let envContent = fs.readFileSync(envPath, "utf8");
  if (!envContent.includes(`${key}=`)) {
    envContent += `\n${key}=${id}\n`;
  } else {
    envContent = envContent.replace(
      new RegExp(`${key}=.*`, "g"),
      `${key}=${id}`
    );
  }
  fs.writeFileSync(envPath, envContent);
  if (key === "MESSAGE_ID_ROLES") MESSAGE_ID_ROLES = id;
  if (key === "MESSAGE_ID_REGLAS") MESSAGE_ID_REGLAS = id;
}

// Mensaje en el canal de roles para que la gente pueda elegir su rol. Si no existe, lo crea y guarda su ID en .env
async function initRoleMessage() {
  const channel = await client.channels
    .fetch(CHANNEL_ID_ROLES)
    .catch(console.error);
  if (!channel?.isTextBased()) return;
  let msg = null;
  if (MESSAGE_ID_ROLES) {
    try {
      msg = await channel.messages.fetch(MESSAGE_ID_ROLES);
    } catch {
      msg = null;
    }
  }
  if (!msg) {
    msg = await channel
      .send({
        embeds: [
          new EmbedBuilder().setTitle("Seleccion√° tu rol").setDescription(
            Object.entries(ROLES)
              .map(([emoji, id]) => `${emoji}  ‚Äì  <@&${id}>`)
              .join("\n")
          ),
        ],
      })
      .catch(console.error);
    if (!msg) return;
    for (const emoji of Object.keys(ROLES)) {
      await msg.react(emoji).catch(console.error);
    }
    saveIdToEnv("MESSAGE_ID_ROLES", msg.id);
    console.log("üìÑ Mensaje de roles inicializado.");
  } else {
    console.log("üìÑ Mensaje de roles ya existe.");
  }
}

// Mensaje en el canal de reglas para que la gente reaccione y verifique. Si no existe, lo crea y guarda su ID en .env
async function initRulesMessage() {
  const channel = await client.channels
    .fetch(CHANNEL_ID_REGLAS)
    .catch(console.error);
  if (!channel?.isTextBased()) return;

  if (!MESSAGE_ID_REGLAS) {
    const msg = await channel
      .send({
        embeds: [
          new EmbedBuilder()
            .setTitle("üö®  REGLAS DEL SERVIDOR üö®")
            .setDescription(
              `‚òëÔ∏è  Invitamos a acualizar tu nick usando tu nombre/apodo y sumando tus pronombres.\n` +
                `‚òëÔ∏è  Sentite libre de hablar, debatir, recomendar, preguntar y compartir lo que quieras.\n` +
                `‚òëÔ∏è  Los canales est√°n abiertos para que te los apropies y puedas ser parte activa de esta comunidad.\n` +
                `‚òëÔ∏è  Invitamos a utilizar la herramienta de spoilers en im√°genes y textos con contenido sensible y acompa√±ar con una Advertencia de Contenido acorde. Por ejemplo: "AC: violencia" + texto con spoiler.\n\n` +
                `‚ùå  Actitudes de transodio, homofobia, racismo, capacitismo y cualquier otra forma de discriminaci√≥n ser√°n motivo de expulsi√≥n.\n` +
                `‚ùå  Cualquier forma de acoso u hostigamiento ser√°n motivo de expulsi√≥n.\n` +
                `‚ùå  Temas no permitidos: spam y publicidades, cualquier contenido que promueva discursos de odio.\n` +
                `‚ùå  Respet√° y valid√° experiencias de les otres, no insultes ni faltes el respeto a ningune miembre.\n\n` +
                `Sentinte habilitade/a/o a contactarte con algune admin frente a cualquier incomodidad!\n\n` +
                `Al reaccionar con ${VERIFICATION_EMOJI} a este mensaje, confirm√°s que le√≠ste y acept√°s estas reglas. ¬°Bienvenide a la comunidad!`
            )
            .setColor("#0099ff"),
        ],
      })
      .catch(console.error);

    if (!msg) return;
    await msg.react(VERIFICATION_EMOJI).catch(console.error);
    saveIdToEnv("MESSAGE_ID_REGLAS", msg.id);
    console.log("üìÑ Mensajes de reglas e im√°genes enviados.");
  } else {
    console.log("üìÑ Mensaje de reglas ya existe.");
  }
}

client.once(Events.ClientReady, async () => {
  await initRoleMessage();
  await initRulesMessage();
  console.log(`üöÄ ${client.user.tag} est√° en l√≠nea!`);
});

// Evento que se dispara cuando un nuevo miembro se une al servidor. Asigna el rol de no verificado y el rol de comunidad directamente cuando se verifica
client.on(Events.GuildMemberAdd, async (member) => {
  // Asignar el rol de no verificado si est√° configurado
  if (UNVERIFIED_ROLE_ID) {
    const unverifiedRole = member.guild.roles.cache.get(UNVERIFIED_ROLE_ID);
    if (unverifiedRole) {
      await member.roles.add(unverifiedRole).catch(console.error);
      console.log(
        `üîí ${member.user.tag} se uni√≥ y se le asign√≥ el rol no verificado.`
      );
    } else {
      console.log(
        `‚ö†Ô∏è Rol no verificado con ID ${UNVERIFIED_ROLE_ID} no encontrado.`
      );
    }
  } else {
    // Si no hay rol no verificado, asignar el rol de comunidad directamente (comportamiento anterior)
    const comunidadRoleId = ROLES["üß°"];
    if (comunidadRoleId) {
      await member.roles.add(comunidadRoleId).catch(console.error);
    }
  }

  const channel = member.guild.channels.cache.get(CHANNEL_ID_BIENVENIDA);
  if (!channel?.isTextBased()) return;
  await channel
    .send(
      `Hola <@${member.id}>, bienvenide/a/o a Transistemas Comunidad! üè≥Ô∏è‚Äç‚ößÔ∏èüè≥Ô∏è‚Äçüåà\n
Para obtener acceso completo al servidor, por favor lee las <#${CHANNEL_ID_REGLAS}> y reacciona con ${VERIFICATION_EMOJI} al mensaje de reglas para confirmar que las has le√≠do y aceptado.\n
Una vez verificado, podr√°s seleccionar tu rol en <#${CHANNEL_ID_ROLES}> y presentarte en <#${CHANNEL_ID_PRESENTACION}>.`
    )
    .catch(console.error);
});

// Evento que se dispara cuando alguien reacciona al mensaje de roles o al mensaje de reglas
client.on(Events.MessageReactionAdd, async (reaction, user) => {
  if (user.bot) return;

  // Manejo de roles (comportamiento existente)
  if (reaction.message.id === MESSAGE_ID_ROLES) {
    const roleId = ROLES[reaction.emoji.name];
    if (!roleId) return;
    const member = await reaction.message.guild.members
      .fetch(user.id)
      .catch(console.error);
    if (!member) return;
    await member.roles.add(roleId).catch(console.error);
    console.log(`‚ûï Rol ${reaction.emoji.name} a√±adido a ${user.tag}.`);
    return; // Salir para no procesar como verificaci√≥n de reglas
  }

  // Manejo de verificaci√≥n de reglas
  if (
    reaction.message.id === MESSAGE_ID_REGLAS &&
    reaction.emoji.name === VERIFICATION_EMOJI
  ) {
    const member = await reaction.message.guild.members
      .fetch(user.id)
      .catch(console.error);
    if (!member) return;

    const unverifiedRole = member.guild.roles.cache.get(UNVERIFIED_ROLE_ID);
    const comunidadRole = member.guild.roles.cache.get(ROLES["üß°"]);

    if (unverifiedRole && member.roles.cache.has(unverifiedRole.id)) {
      await member.roles.remove(unverifiedRole).catch(console.error);
      console.log(`üîì Rol no verificado removido de ${user.tag}.`);
    }

    if (comunidadRole && !member.roles.cache.has(comunidadRole.id)) {
      await member.roles.add(comunidadRole).catch(console.error);
      console.log(
        `‚úÖ Rol de comunidad a√±adido a ${user.tag} por verificaci√≥n de reglas.`
      );
    }
  }
});

// Evento que se dispara cuando alguien quita una reacci√≥n del mensaje de roles o del mensaje de reglas
client.on(Events.MessageReactionRemove, async (reaction, user) => {
  if (user.bot) return;

  // Manejo de roles (comportamiento existente)
  if (reaction.message.id === MESSAGE_ID_ROLES) {
    const roleId = ROLES[reaction.emoji.name];
    if (!roleId) return;
    const member = await reaction.message.guild.members
      .fetch(user.id)
      .catch(console.error);
    if (!member) return;
    await member.roles.remove(roleId).catch(console.error);
    console.log(`‚ûñ Rol ${reaction.emoji.name} removido de ${user.tag}.`);
  }
  // No hay un caso de "desverificaci√≥n" de reglas al quitar la reacci√≥n,
  // ya que una vez que se verifica, se asume que el usuario tiene acceso.
});

// Evento que se dispara cuando un mensaje es enviado
client.on(Events.MessageCreate, async (message) => {
  if (message.author.bot) return;

  const content = message.content.toLowerCase();

  // 1. Detecci√≥n de spam basado en contenido y repetici√≥n
  let isSpamKeyword = SPAM_KEYWORDS.some((keyword) =>
    content.includes(keyword)
  );

  if (!recentMessages.has(content)) {
    recentMessages.set(content, []);
  }

  const messagesByContent = recentMessages.get(content);
  messagesByContent.push({
    author: message.author.id,
    channel: message.channel.id,
    timestamp: Date.now(),
  });

  // Limpiar mensajes antiguos
  recentMessages.set(
    content,
    messagesByContent.filter(
      (msg) => Date.now() - msg.timestamp < SPAM_TIME_WINDOW
    )
  );

  const spamInstances = recentMessages
    .get(content)
    .filter((msg) => Date.now() - msg.timestamp < SPAM_TIME_WINDOW);

  const isRepetitiveSpam = spamInstances.length >= SPAM_THRESHOLD;

  if (isSpamKeyword || isRepetitiveSpam) {
    try {
      await message.delete();
      console.log(
        `üö´ Mensaje de spam detectado y eliminado de ${message.author.tag} en #${message.channel.name}: "${message.content}"`
      );

      // Enviar notificaci√≥n a un webhook si est√° configurado
      if (SPAM_WEBHOOK_URL) {
        const embed = new EmbedBuilder()
          .setTitle("üö´ Posible Spam Detectado y Eliminado")
          .setDescription(
            `Un mensaje sospechoso ha sido detectado y eliminado.`
          )
          .setColor("#FF0000")
          .addFields(
            { name: "Usuario", value: `<@${message.author.id}>` },
            { name: "Canal", value: `<#${message.channel.id}>` },
            { name: "Contenido", value: `\`\`\`${message.content}\`\`\`` },
            {
              name: "Razones",
              value: `${isSpamKeyword ? "Palabras clave de spam " : ""}${
                isRepetitiveSpam
                  ? "Mensaje repetitivo en m√∫ltiples canales"
                  : ""
              }`,
            }
          )
          .setTimestamp();

        await fetch(SPAM_WEBHOOK_URL, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({ embeds: [embed] }),
        }).catch((err) =>
          console.error("‚ùå Error al enviar notificaci√≥n de spam:", err)
        );
      }
    } catch (error) {
      console.error(
        `‚ùå No se pudo eliminar el mensaje de spam: ${error.message}`
      );
    }
  }
});

client.login(process.env.BOT_TOKEN).catch(() => {
  console.error(
    "‚ùå Error al iniciar sesi√≥n en Discord. ¬°Verifica tu BOT_TOKEN!"
  );
});

// √ötil para evitar problemas al detener el bot
process.on("SIGINT", () => {
  console.log("üëã Apagando el bot...");
  client.destroy();
  process.exit(0);
});
